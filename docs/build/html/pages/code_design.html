<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>QC plots code design &mdash; TCCON QC  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="API: qc_plots2 module" href="auto_qc_plots2.html" />
    <link rel="prev" title="TCCON QC Configuration" href="configuration.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> TCCON QC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="configuration.html">TCCON QC Configuration</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">QC plots code design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#plot-instance-methods">Plot instance methods</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-style-keywords">Getting style keywords</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-legend-keywords">Getting legend keywords</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#auxiliary-plots">Auxiliary plots</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#loading-extra-data">Loading extra data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pros-and-cons-this-auxiliary-plot-design">Pros and cons this auxiliary plot design</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="auto_qc_plots2.html">API: qc_plots2 module</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">TCCON QC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>QC plots code design</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/pages/code_design.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="qc-plots-code-design">
<h1>QC plots code design<a class="headerlink" href="#qc-plots-code-design" title="Permalink to this headline"></a></h1>
<p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">qc_plots2</span></code> module follows an object-oriented approach to the data and plots. Datasets are represented
by <code class="xref py py-class docutils literal notranslate"><span class="pre">qc_plots2.TcconData</span></code> instances. These instances wrap a netCDF dataset and provide several methods to
access the data - <code class="docutils literal notranslate"><span class="pre">get_data</span></code> and <code class="docutils literal notranslate"><span class="pre">get_flag0_or_all_data</span></code>. The former will return a certain category of data
(all, flag = 0, or flag &gt; 0 data currently). Using these intermediate methods allows the instance to impose some
additional constraints on the data returned; for example, reference data is configured to limit what it returns
to the same time period as the main (and context, if available) data. The second method provides the “default”
data, which is flag = 0 data if that instance knows how to find flag = 0 data, otherwise it is all data.</p>
<p>Plots are represented by subclasses of the <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot" title="qc_plots.qc_plots2.AbstractPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractPlot</span></code></a> class. This abstract
class defines the framework of methods any plot kind must implement. Each plot kind allowed in the configuration
file has a corresponding class in <a class="reference internal" href="auto_qc_plots2.html#module-qc_plots.qc_plots2" title="qc_plots.qc_plots2"><code class="xref py py-mod docutils literal notranslate"><span class="pre">qc_plots2</span></code></a>. The figure below shows the inheritance graph
for the various plot classes. When one plot needs only to add or adjust functionality of another, it can inherit
from another concrete plot class. For example, several plot kinds inherit from <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimeseriesPlot" title="qc_plots.qc_plots2.TimeseriesPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeseriesPlot</span></code></a>,
as they are fundamentally time series, but with additional functionality.</p>
<figure class="align-default" id="id1">
<div class="graphviz"><img src="../_images/inheritance-0fde4ee08bd8efc4e264cae9dc286856b275753d.png" alt="Inheritance diagram of qc_plots.qc_plots2.ResampledTimeseriesPlot, qc_plots.qc_plots2.RollingDerivativePlot, qc_plots.qc_plots2.RollingTimeseriesPlot, qc_plots.qc_plots2.Timeseries2PanelPlot, qc_plots.qc_plots2.TimeseriesDeltaPlot, qc_plots.qc_plots2.HexbinPlot, qc_plots.qc_plots2.TimingErrorMultipleSZAs, qc_plots.qc_plots2.TimingErrorAMvsPM, qc_plots.qc_plots2.FlagAnalysisPlot" usemap="#inheritance295970adb6" class="inheritance graphviz" /></div>
<map id="inheritance295970adb6" name="inheritance295970adb6">
<area shape="rect" id="node14" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimingErrorAbstractPlot" target="_top" title="Intermediate abstract plot class for timing error plots" alt="" coords="168,177,331,200"/>
<area shape="rect" id="node2" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot" target="_top" title="The abstract parent class for all concrete plotting classes." alt="" coords="18,83,111,107"/>
<area shape="rect" id="node3" href="auto_qc_plots2.html#qc_plots.qc_plots2.FlagAnalysisPlot" target="_top" title="Concrete plotting class that generates bar graphs for the number/percent of spectra flagged by different variables" alt="" coords="190,83,309,107"/>
<area shape="rect" id="node5" href="auto_qc_plots2.html#qc_plots.qc_plots2.ScatterPlot" target="_top" title="Concrete plotting class for plotting one variable against another" alt="" coords="207,38,293,61"/>
<area shape="rect" id="node4" href="auto_qc_plots2.html#qc_plots.qc_plots2.HexbinPlot" target="_top" title="Concrete plotting class for a 2D histogram of one variable vs. another" alt="" coords="417,38,502,61"/>
<area shape="rect" id="node7" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimeseriesPlot" target="_top" title="Concrete plotting class for simple timeseries of data" alt="" coords="405,96,514,119"/>
<area shape="rect" id="node6" href="auto_qc_plots2.html#qc_plots.qc_plots2.ResampledTimeseriesPlot" target="_top" title="Concrete plotting class to plot a timeseries of data resampled to a coarser temporal frequency." alt="" coords="588,5,763,28"/>
<area shape="rect" id="node8" href="auto_qc_plots2.html#qc_plots.qc_plots2.RollingDerivativePlot" target="_top" title="Concrete plotting class to plot a derivative of one variable vs. another over a rolling window." alt="" coords="602,50,748,74"/>
<area shape="rect" id="node9" href="auto_qc_plots2.html#qc_plots.qc_plots2.RollingTimeseriesPlot" target="_top" title="Concrete plotting class to plot a rolling mean/median/etc timeseries." alt="" coords="601,96,750,119"/>
<area shape="rect" id="node10" href="auto_qc_plots2.html#qc_plots.qc_plots2.Timeseries2PanelPlot" target="_top" title="Concrete plotting class for a two&#45;panel plot, with a second time series in a smaller upper plot" alt="" coords="601,141,750,164"/>
<area shape="rect" id="node11" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimeseriesDeltaPlot" target="_top" title="Concrete plotting class for time series that plot the difference of two variables." alt="" coords="604,186,747,210"/>
<area shape="rect" id="node12" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimeseriesMixin" target="_top" title="Mixin class that provides common utilities for timeseries plots" alt="" coords="5,130,124,153"/>
<area shape="rect" id="node13" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimingErrorAMvsPM" target="_top" title="Concrete plotting class that creates plots to detect timing error by morning/afternoon differences" alt="" coords="390,199,529,222"/>
<area shape="rect" id="node15" href="auto_qc_plots2.html#qc_plots.qc_plots2.TimingErrorMultipleSZAs" target="_top" title="Concrete plot to identify timing errors from averages in different SZA ranges." alt="" coords="375,153,543,177"/>
</map><figcaption>
<p><span class="caption-text">Inheritance diagram for the various plot classes. Note that <code class="docutils literal notranslate"><span class="pre">ABC</span></code> is the abstract base class,
not actually a plot class.</span><a class="headerlink" href="#id1" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>There is a very close correspondance between the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of the plot classes and the plot configuration
file. Except for the <code class="docutils literal notranslate"><span class="pre">self</span></code>, <code class="docutils literal notranslate"><span class="pre">other_plots</span></code>, <code class="docutils literal notranslate"><span class="pre">default_style</span></code>, and <code class="docutils literal notranslate"><span class="pre">limits</span></code> keyword, all the arguments in a
plot class’s <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method correspond to valid configuration options in the plot configuration file. Arguments
without a default value are required in the configuration file, others are optional.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot.from_config_section" title="qc_plots.qc_plots2.AbstractPlot.from_config_section"><code class="xref py py-meth docutils literal notranslate"><span class="pre">from_config_section()</span></code></a> method creates plot class instances from
sections in the configuration file.</p>
</div>
<section id="plot-instance-methods">
<h2>Plot instance methods<a class="headerlink" href="#plot-instance-methods" title="Permalink to this headline"></a></h2>
<p>The idea behind separating each plot type into its own class is that this keeps code for each plot class grouped
together, but encourages reuse of code by inheriting from parent classes. In this section, we’ll go over the general
structure of a plot class and cover the main methods that you would likely customize one or more of in new plot
classes. Below is a figure showing the relationship among these methods.</p>
<figure class="align-default" id="id2">
<div class="graphviz"><img src="../_images/graphviz-512ed1948141ff97c1f844e11401df809b51626f.png" alt="digraph {
    &quot;make_plots&quot; -&gt; &quot;setup_figure&quot;;
    &quot;make_plots&quot; -&gt; &quot;_plot&quot;;
    &quot;make_plots&quot; -&gt; &quot;get_save_name&quot;;
    &quot;_plot&quot; -&gt; &quot;get_plot_args&quot;;
    &quot;get_plot_args&quot; -&gt; &quot;get_plot_data&quot;;
    &quot;get_plot_args&quot; -&gt; &quot;get_plot_kws&quot;;
    &quot;get_plot_args&quot; -&gt; &quot;get_legend_kws&quot;;
}" class="graphviz" /></div>
<figcaption>
<p><span class="caption-text">Call structure for the key methods in a plot class.</span><a class="headerlink" href="#id2" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>In any plot class, the <code class="docutils literal notranslate"><span class="pre">make_plots</span></code> method is the main entry point. This will be called by the main script with
relevant command line values (like where to save the figure to) as well as a list of all available data, as
<a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TcconData" title="qc_plots.qc_plots2.TcconData"><code class="xref py py-class docutils literal notranslate"><span class="pre">TcconData</span></code></a> instances. It must ultimately save a figure as an image (usually PNG format)
and return a path to that image.</p>
<p><code class="docutils literal notranslate"><span class="pre">make_plots</span></code> usually first calls <code class="docutils literal notranslate"><span class="pre">setup_figure</span></code>. This method is responsible for creating the figure and axes to
plot into, as well as setting limits, axes labels, tick formatting, etc. It must return the handle to the figure and
axes (or array of axes handles, if &gt;1 axes needed).</p>
<p><code class="docutils literal notranslate"><span class="pre">_plot</span></code> handles the actual plotting. It is called with each <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TcconData" title="qc_plots.qc_plots2.TcconData"><code class="xref py py-class docutils literal notranslate"><span class="pre">TcconData</span></code></a> instance in turn;
if one or more of those instances should be skipped, <code class="docutils literal notranslate"><span class="pre">make_plots</span></code> should skip it. (For example, the
<a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.FlagAnalysisPlot" title="qc_plots.qc_plots2.FlagAnalysisPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">FlagAnalysisPlot</span></code></a> only plots the main data, so <code class="docutils literal notranslate"><span class="pre">make_plots</span></code> handles skipping over the
reference and context data, if they are present.)</p>
<p>Within <code class="docutils literal notranslate"><span class="pre">_plot</span></code>, usually the first step is to call <code class="docutils literal notranslate"><span class="pre">get_plot_args</span></code>, which returns a list of arguments for separate
plotting calls. Each entry in the list represents a different subset of the data to plot. For example, if plotting
flag = 0 and flag &gt; 0 data separately, then <code class="docutils literal notranslate"><span class="pre">get_plot_args</span></code> would return a two-element list. Each element of the
list is <em>usually</em> a dictionary, often with keys “data”, “kws”, and “legend_kws”. “data” points to the data that will
be plotted, “kws” would have the style keywords to pass to the plotting function, and “legend_kws” would have keywords
to use when creating the legend.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Often “legend_kws” values are only used from the first element in a list of plot arguments.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">get_plot_args</span></code> relies on three other functions to get the different parts of the arguments. <code class="docutils literal notranslate"><span class="pre">get_plot_data</span></code> should,
given a <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TcconData" title="qc_plots.qc_plots2.TcconData"><code class="xref py py-class docutils literal notranslate"><span class="pre">TcconData</span></code></a> instance and a flag category (e.g. all, flag = 0, or flag &gt; 0 data),
return the subset of data corresponding to the given flag category to use in the plot for that. Any preprocessing of the
data (like calculating rolling medians) usually happens in <code class="docutils literal notranslate"><span class="pre">get_plot_data</span></code>. Likewise, <code class="docutils literal notranslate"><span class="pre">get_plot_kws</span></code> returns the style
keywords to use for the given flag category. This is also where fallback styles are usually set; for instance,
<a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.ScatterPlot" title="qc_plots.qc_plots2.ScatterPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScatterPlot</span></code></a> will set the linestyle to “none” and marker to “.” if those weren’t set by
any of the configured styles, since these are needed to make a scatter plot, rather than a line plot. Finally,
<code class="docutils literal notranslate"><span class="pre">get_legend_kws</span></code> returns style keywords for the legend, merging legend keywords from the style with plot-specific keyword.</p>
<p>Back in <code class="docutils literal notranslate"><span class="pre">_plot</span></code>, once it has received the list of plotting arguments, it loops through them and plots each subset
of data into the axes provided to it. Once the plotting is complete, <code class="docutils literal notranslate"><span class="pre">make_plots</span></code> will need to save the plot as a PNG
and return the path to that image.</p>
<section id="getting-style-keywords">
<h3>Getting style keywords<a class="headerlink" href="#getting-style-keywords" title="Permalink to this headline"></a></h3>
<p>Getting the final set of style keywords for a given plot can be complicated, since it needs to merge default styles for
a given plot type with data type-specific styles. When the plot configuration file is read, default styles are stored in
each concrete plot instance. The plot instances each store styles for <em>all</em> plot kinds, in order to allow for styles to
be cloned from one plot kind to another. Likewise, each <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TcconData" title="qc_plots.qc_plots2.TcconData"><code class="xref py py-class docutils literal notranslate"><span class="pre">TcconData</span></code></a> instance stores the
dictionary of plot styles relevant for its data category (main, context, reference).</p>
<p>Recall from the <a class="reference internal" href="configuration.html#styles"><span class="std std-ref">Styles</span></a> section of the configuration documentation that styles are organized by
<code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">category</span> <span class="pre">-&gt;</span> <span class="pre">plot</span> <span class="pre">kind</span> <span class="pre">-&gt;</span> <span class="pre">data</span> <span class="pre">subset</span></code>. Generally the algorithm that <code class="docutils literal notranslate"><span class="pre">get_plot_kws</span></code> follows is:</p>
<ol class="arabic simple">
<li><p>Get the default styles for the current plot kind from the <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot" title="qc_plots.qc_plots2.AbstractPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractPlot</span></code></a>
subclass instance.</p></li>
<li><p>If the default styles have a style for the current data subset, get that style. If not, but do have a
“clone” directive, get the styles for the cloned plot kind and check if those have the right data subset.
If not, return an empty dict.</p></li>
<li><p>Get the data category-specific styles from the <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.TcconData" title="qc_plots.qc_plots2.TcconData"><code class="xref py py-class docutils literal notranslate"><span class="pre">TcconData</span></code></a> instance. Follow
the same approach as for the default styles to get the subset-specific style.</p></li>
<li><p>Merge the default and data category-specific options, with the specific options overriding the default options
wherever there is a conflict.</p></li>
</ol>
<p>Implementations of <code class="docutils literal notranslate"><span class="pre">get_plot_kws</span></code> usually rely heavily on the helper <code class="docutils literal notranslate"><span class="pre">_get_style</span></code> method. This method handles getting
the correct style for the data subset, including looking it up from the cloned plot type if needed.</p>
</section>
<section id="getting-legend-keywords">
<h3>Getting legend keywords<a class="headerlink" href="#getting-legend-keywords" title="Permalink to this headline"></a></h3>
<p>Legend keywords can be specified differently for different instances of the same plot kind. To keep things simple,
legend keywords defined in the style section of the configuration file, rather than the plots section, can only be
defined in the “default” subsection, not any of the data category-specific subsections. When a plot instance is created,
any plot-specific legend keywords are stored on that instance. The <code class="docutils literal notranslate"><span class="pre">get_legend_kws</span></code> method then only has to retrieve the
default style legend keywords and merge them with the instance-specific keywords. It also relies on the <code class="docutils literal notranslate"><span class="pre">_get_style</span></code>
method to retrieve the default legend style, in order to allow legend keywords to be cloned just like the plot styles
themselves.</p>
</section>
</section>
<section id="auxiliary-plots">
<h2>Auxiliary plots<a class="headerlink" href="#auxiliary-plots" title="Permalink to this headline"></a></h2>
<p>Auxiliary plots are currently implemented as mixin-type classes that inherit from the abstract class
<code class="xref py py-class docutils literal notranslate"><span class="pre">qc_plots.qc_plots2.AuxPlotMixin</span></code>. For an example, see the <code class="xref py py-class docutils literal notranslate"><span class="pre">qc_plots.qc_plots2.ViolinAuxPlot</span></code>
class and its usage. Note how it is always the <em>second</em> parent class of classes that inherit from it. These classes
can assume they will have access through <code class="docutils literal notranslate"><span class="pre">self</span></code> to any methods defined on <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot" title="qc_plots.qc_plots2.AbstractPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractPlot</span></code></a>.</p>
<p>To enable a main plot + auxiliary plot combination, you will need to implement a class that inherits from both the main plot
class and the auxiliary plot mixin class. The <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method of the combined class will need to accept arguments required by
both and distribute them to the parent classes appropriately. For this reason, it is best if the auxiliary plot mixin class
does its initialization in a method <em>other</em> than <code class="docutils literal notranslate"><span class="pre">__init__</span></code>, so that the combined class can easily call it explicitly.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It will make things much easier on users if you keep the auxiliary input parameter names the same for all combined classes using
a particular auxiliary mixin. For example, all of the classes that inherit from <code class="xref py py-class docutils literal notranslate"><span class="pre">ViolinAuxPlot</span></code>
use <code class="docutils literal notranslate"><span class="pre">violin_data_file</span></code> as the parameter to accept the path to the file to plot data from. This way the user can always
use the same line in their config file, and won’t have to change the parameter key across main plot types.</p>
</div>
<p>Since the auxiliary plot has the potential to be inherited by many child classes, it will be helpful if you can encapsulate most
of the functionality needed to plot both the main and auxiliary plots on the auxiliary mixin class. In
<code class="xref py py-class docutils literal notranslate"><span class="pre">qc_plots.qc_plots2.ViolinAuxPlot</span></code>, this is accomplished by having alternatively-named versions of key methods
(such as <code class="docutils literal notranslate"><span class="pre">setup_figure_with_violins</span></code> in lieu of <code class="docutils literal notranslate"><span class="pre">setup_figure</span></code> or <code class="docutils literal notranslate"><span class="pre">get_save_name_with_violins</span></code> in lieu of
<code class="docutils literal notranslate"><span class="pre">get_save_name</span></code>). These call their normal versions as needed internally. The overall behavior is wrapped up in
<code class="docutils literal notranslate"><span class="pre">make_plot_with_violins</span></code>, which combines calls to the alternative and regular methods as needed. In most classes that inherit
from <code class="xref py py-class docutils literal notranslate"><span class="pre">qc_plots.qc_plots2.ViolinAuxPlot</span></code>, all that is needed is to call <code class="docutils literal notranslate"><span class="pre">make_plot_with_violins</span></code> from inside the
<code class="docutils literal notranslate"><span class="pre">make_plot</span></code> method, and everything is taken care of with minimal code duplication.</p>
<p>As each main + auxiliary plot combination is its own child of <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.AbstractPlot" title="qc_plots.qc_plots2.AbstractPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">AbstractPlot</span></code></a>, each must have
a unique <code class="docutils literal notranslate"><span class="pre">plot_kind</span></code> attribute. This should have the form of “main_plot+aux_plot”, e.g. “timeseries+violin”. Being consistent
about the auxiliary plot component of the name across all implementations will make it easier for users to remember the correct
name when writing their configuration files.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is <strong>critical</strong> that the part before the <code class="docutils literal notranslate"><span class="pre">+</span></code> matches the main plot’s <code class="docutils literal notranslate"><span class="pre">plot_kind</span></code> value exactly. Both
<code class="xref py py-meth docutils literal notranslate"><span class="pre">_get_style()</span></code> and <a class="reference internal" href="auto_qc_plots2.html#qc_plots.qc_plots2.Limits" title="qc_plots.qc_plots2.Limits"><code class="xref py py-class docutils literal notranslate"><span class="pre">Limits</span></code></a> rely on this
to fall back on the proper main plot style/limits if needed.</p>
</div>
<section id="loading-extra-data">
<h3>Loading extra data<a class="headerlink" href="#loading-extra-data" title="Permalink to this headline"></a></h3>
<p>Each auxiliary mixin must define the method <code class="docutils literal notranslate"><span class="pre">get_extra_data_files_required</span></code> that returns a sequence of paths to netCDF files
to load. The main function will load each unique file once and store it in a dictionary. The mixin will receive this dictionary
to its <code class="docutils literal notranslate"><span class="pre">make_plot</span></code> method and will be responsible for pulling out the correct dataset. Since converting the time dimensions
in each of the input files is one of the slower parts of this code, this approach avoids doing that more than necessary.</p>
</section>
<section id="pros-and-cons-this-auxiliary-plot-design">
<h3>Pros and cons this auxiliary plot design<a class="headerlink" href="#pros-and-cons-this-auxiliary-plot-design" title="Permalink to this headline"></a></h3>
<p>In theory, this approach of having combination plot classes that inherit from both the main and auxiliary plot class provides
flexibility in implementation. The combination class can override whatever methods from its parents it needs to make that specific
combination work.</p>
<p>The main downside is that it still requires quite a bit of manual work to implement each combination class; the custom <code class="docutils literal notranslate"><span class="pre">__init__</span></code>
method that divides up the various inputs must be created, and at the very least, the <code class="docutils literal notranslate"><span class="pre">make_plot</span></code> method needs overridden to
correctly make both the main and auxiliary plots. This puts a severe limit on the possibility of combining more than one auxiliary
plot with any given main plot, as a unique class would have to be created for each possible combination.</p>
<p>A cleaner approach would be to compose a master plotting class out of one main and zero or more auxiliary plotting classes. This
master class would need to deduce how to set up the figure based on the requirements of all the component plots, then distribute
the correct axes and data to each component. If those problems could be solved, this code could be significantly simplified.
A related redesign could separate data extraction from plotting, thus each master plot would have components:</p>
<ul class="simple">
<li><p>a data loader that extracts variables from each of the input datasets</p></li>
<li><p>one or more plotters that take the data provided by the loader and its axes and creates the desired plots</p></li>
</ul>
<p>Separating the data loader from the plotter should reduce the complexity of the inheritance in this code (ideally to only
a single layer: <code class="docutils literal notranslate"><span class="pre">AbstractDataLoader</span> <span class="pre">-&gt;</span> <span class="pre">ConcreteDataLoaders</span></code>, etc.). This would be a prime example of using
<a class="reference external" href="https://realpython.com/inheritance-composition-python/#the-class-explosion-problem">composition over inheritance</a>,
but needs a not-insignificant rebuild to implement.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="configuration.html" class="btn btn-neutral float-left" title="TCCON QC Configuration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="auto_qc_plots2.html" class="btn btn-neutral float-right" title="API: qc_plots2 module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Sebastien Roche, Joshua Laughner.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>